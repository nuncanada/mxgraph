<!--
  Copyright (c) 2006-2013, JGraph Ltd

  Schema example for mxGraph. This example demonstrates implementing
  a SQL schema editor.

  IMPLEMENT:

  - Ditch current properties editing for the usual RAD properties column on the right
  - Fix abstract entities to appear different - already existing style abstractEntity
  - Stop Relationships from stacking/hiding one another
  - Improve the algorithm to display self-relationships
  - Relationships can also have properties/columns
  - align arrows in relationship edge
  - Create separate UUID PSEUDO Column object from Columns
  - Button apply changes
  - PHP (Javascript????) Parser for the generated XML
  - CREATE/ALTER tables in PostgreSQL
  - How to create transactional indexes for computed values?
  - Both backend and frontend caching in synchronicity
  - Frontend templates parsing for columns/computedValues
  - Template editor with formula builder
  - State Handling -- There should be interaction between different editors (State Modeler and Schema Editor)
  - Authorization handler
  - Javascript code for autocompleting columns/relationships/computedValues
  - Constraints formula builder
  - ComputedValues formula builder
  - webpack bundling
  - Properly separate code here in different files/modules
  - Import tool for data from existing databases
    - Keep synchronizing to an existing database with an overlay (?Is this worth the huge complexity?)

-->
<html>
<head>
    <title>EzApp Schema Editor</title>

    <meta charset="UTF-8">

    <!-- Sets the basepath for the library if not in same directory -->
    <script type="text/javascript">
		mxBasePath = '../src';
    </script>

    <!-- Loads and initializes the library -->
    <script type="text/javascript" src="../src/js/mxClient.js"></script>

    <!-- Font Awesome -->
    <link href="../src/fontawesome-5.15.4/css/all.css" rel="stylesheet">
    <script defer type="text/javascript" src="../src/fontawesome-5.15.4/all.js"></script>

    <!-- Example code -->
    <script type="text/javascript">

		function uuidv4() {
			return ([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g, c =>
				(c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16)
			);
		}

		function updateVisualizationToData(graph, cell) {
			//Quando mexe no gráfico. Queremos que já seja visualizada as modificações depois do OK
			//Muito difícil de achar essas incantações mágicas nesse código do mxGraph...

			const state = graph.view.getState(cell);
			graph.cellRenderer.redraw(state);
        }

        //Function to be added when we have a graph and called from the Lanes to create new Objects
        let addNewItem = null;

		const CELL_STYLES = {
			ENTITY: "entity",
			ABSTRACT_ENTITY: "abstract_entity",
			ENTITY_LANE: "entity_lane"
		};

		// Program starts here. Creates a sample graph in the
		// DOM node with the specified ID. This function is invoked
		// from the onLoad event handler of the document (see below).
		function main (container, outline, toolbar, sidebar, status) {
			// Checks if the browser is supported
			if (!mxClient.isBrowserSupported()) {
				// Displays an error message if the browser is not supported.
				mxUtils.error('Browser is not supported!', 200, false);
			} else {
				//Achava que era o grid mas não é...
				//mxGraphHandler.prototype.guidesEnabled = true;

				// Specifies shadow opacity, color and offset
				mxConstants.SHADOW_OPACITY = 0.5;
				mxConstants.SHADOWCOLOR = '#C0C0C0';
				mxConstants.SHADOW_OFFSET_X = 5;
				mxConstants.SHADOW_OFFSET_Y = 6;

				// Entity icon dimensions and position
				mxSwimlane.prototype.imageSize = 20;
				mxSwimlane.prototype.imageDx = 16;
				mxSwimlane.prototype.imageDy = 4;

				// Changes swimlane icon bounds
				mxSwimlane.prototype.getImageBounds = function (x, y, w, h) {
					return new mxRectangle(x + this.imageDx, y + this.imageDy, this.imageSize, this.imageSize);
				};

				// Defines an icon for creating new connections in the connection handler.
				// This will automatically disable the highlighting of the source vertex.
				mxConnectionHandler.prototype.connectImage = new mxImage('images/connector.gif', 16, 16);

				// Snaps to fixed points
				mxConstraintHandler.prototype.intersects = function (icon, point, source, existingEdge) {
					return (!source || existingEdge) || mxUtils.intersects(icon.bounds, point);
				};

				// Prefetches all images that appear in colums
				// to avoid problems with the auto-layout
				const keyImage = new Image();
				keyImage.src = "images/key.png";

				const plusImage = new Image();
				plusImage.src = "images/plus.png";

				const checkImage = new Image();
				checkImage.src = "images/check.png";


				// Creates the graph inside the given container. The
				// editor is used to create certain functionality for the
				// graph, such as the rubberband selection, but most parts
				// of the UI are custom in this example.
				const editor = new mxEditor();
				const graph = editor.graph;
				const model = graph.model;

				//Ativa o grid
				graph.graphHandler.scaleGrid = true;
				graph.setPanning(true);

				// Disables some global features
				graph.setConnectable(true);
				graph.setCellsDisconnectable(false);
				graph.setCellsCloneable(false);
				graph.swimlaneNesting = false;
				graph.dropEnabled = true;

				addNewItem = function(mxObjectId) {
                    const laneCell = graph.model.getCell(mxObjectId);
                    const objectManager = LaneManager.createManagerForLaneObject(laneCell.value.name);
                    objectManager.addNewItem(graph, laneCell);
                };

				//Didn't work?
				//editor.dblClickAction = 'showProperties';

				//Simplesmente colocar true não funcionou.
				//É interessante permitir mudar o ponto que está ligado o edge
				// Does not allow dangling edges
				graph.setAllowDanglingEdges(false);

				//TODO: Review if the setAllowLoops isn't enough
				graph.setAllowLoops(true);
				mxGraph.prototype.allowLoops = true;

				// Forces use of default edge in mxConnectionHandler
				graph.connectionHandler.factoryMethod = null;





				//Modificações Edge State
				graph.getAllConnectionConstraints = function (terminal) {
					if (terminal != null && this.model.isVertex(terminal.cell)) {
						return [
							new mxConnectionConstraint(new mxPoint(0, 0), true),
							new mxConnectionConstraint(new mxPoint(0.33, 0), true),
							new mxConnectionConstraint(new mxPoint(0.66, 0), true),
							new mxConnectionConstraint(new mxPoint(1, 0), true),

							new mxConnectionConstraint(new mxPoint(0, 0.5), true),
							new mxConnectionConstraint(new mxPoint(1, 0.5), true),

							new mxConnectionConstraint(new mxPoint(0, 1), true),
							new mxConnectionConstraint(new mxPoint(0.33, 1), true),
							new mxConnectionConstraint(new mxPoint(0.66, 1), true),
							new mxConnectionConstraint(new mxPoint(1, 1), true),
						];
					}

					return null;
				};

				//Modificações Edge State
				// Connect preview
				graph.connectionHandler.createEdgeState = function (me) {
					var edge = graph.createEdge(null, null, null, null, null, 'edgeStyle=orthogonalEdgeStyle');

					return new mxCellState(this.graph.view, edge, this.graph.getCellStyle(edge));
				};
				//Modificações Edge State
				// Enables rubberband selection
				new mxRubberband(graph);

				let edgeStyle = graph.getStylesheet().getDefaultEdgeStyle();

				edgeStyle[mxConstants.STYLE_EDGE] = mxEdgeStyle.SegmentConnector;

				//Retira o label padrão do Edge que é apenas uma String.
				//No nosso caso queremos 2 labels, um de ida, outro para a volta
				edgeStyle[mxConstants.STYLE_NOLABEL] = true;

				//edgeStyle[mxConstants.STYLE_EDGE] = mxEdgeStyle.EntityRelation;

				// Only entities are resizable
				graph.isCellResizable = function (cell) {
					return [ObjectType.ENTITY].includes(cell.value.objectType);
				};

				// Only entities are movable
				graph.isCellMovable = function (cell) {
					return [ObjectType.ENTITY].includes(cell.value.objectType);
				};

				// Sets the graph container and configures the editor
				editor.setGraphContainer(container);
				var config = mxUtils.load(
					'editors/config/keyhandler-minimal.xml').getDocumentElement();
				editor.configure(config);

				// Configures the automatic layout for the table columns
				editor.layoutSwimlanes = true;
				editor.createSwimlaneLayout = function () {
					var layout = new mxStackLayout(this.graph, false);
					layout.fill = true;
					layout.resizeParent = true;

					// Overrides the function to always return true
					layout.isVertexMovable = function (cell) {
						return true;
					};

					return layout;
				};

				//TODO: This is tied to the double click editing. Should we give up on it?
                //Maybe double clicking should open properties?
				// Text label changes will go into the name field of the user object
				graph.model.valueForCellChanged = function (cell, value) {
					if (value.name != null) {
						return mxGraphModel.prototype.valueForCellChanged.apply(this, arguments);
					} else {
						var old = cell.value.name;
						cell.value.name = value;
						return old;
					}
				};

				graph.isHtmlLabel = function (cell) {
					return [ObjectType.COLUMN, ObjectType.RELATION, ObjectType.LANE].includes(cell.value.objectType);
				};

				graph.isCellEditable = function (cell) {
					return [ObjectType.COLUMN, ObjectType.ENTITY].includes(cell.value.objectType);
				};

				//Disable Lanes being selectable
				graph.isCellSelectable = function (cell) {
					if ([ObjectType.LANE, ObjectType.UUID].includes(cell.value.objectType)) {
						return false;
					}
					return mxGraph.prototype.isCellSelectable.apply(this, arguments); // "supercall"
				};

				// Returns the name field of the user object for the label
				graph.convertValueToString = function (cell) {
					if (cell.value != null && cell.value.name != null) {
						return cell.value.name;
					}

					return mxGraph.prototype.convertValueToString.apply(this, arguments); // "supercall"
				};

				// Returns the type as the tooltip for column cells
				graph.getTooltip = function (state) {
					if (this.isHtmlLabel(state.cell)) {
						return 'Type: ' + state.cell.value.type;
					} else if (this.model.isEdge(state.cell)) {
						return state.cell.source.value.name + ' <-> ' + state.cell.target.value.name;
					}

					return mxGraph.prototype.getTooltip.apply(this, arguments); // "supercall"
				};

				//REMINDER: If this does not work for LANES: mxConnectionHandler.prototype.createIcons
				// Creates a dynamic HTML label for column fields
                //FIXME: This should go to the RelationManager, ColumnManager, LaneManager
				graph.getLabel = function (cell) {
					console.log(cell);
					if (this.isHtmlLabel(cell) && cell.value && cell.value.objectType) {
						console.log(cell);
						switch (cell.value.objectType) {
							case ObjectType.RELATION:
								if (cell.value.isa) {
									//FIXME: Probably it is better to change de style of the edge!
									return '<div>IS A</div>';
								} else {
									//FIXME: Would look better if we align the arrows
									return '<div><div><i class="fas fa-arrow-right"></i>&nbsp;' +
										cell.value.forwardDescription + ' </div> ' +
										'<br/> ' +
										'<div><i class="fas fa-arrow-left"></i>&nbsp;' +
										cell.value.backwardDescription +
										'</div></div>';
								}
								break;
                            case ObjectType.COLUMN:
								var label = '';

								if (cell.value.primaryKey) {
									label += '<img title="Primary Key" src="images/key.png" width="16" height="16" align="top">&nbsp;';
								} else {
									label += '<img src="images/spacer.gif" width="16" height="1">&nbsp;';
								}

								console.log(cell.value);


								return label + mxUtils.htmlEntities(cell.value.name, false) + ': ' +
									mxUtils.htmlEntities(cell.value.type, false);
								break;
							case ObjectType.LANE:
								//TODO: Spent a lot more time than should trying to float this image
                                //to the right, giving up for now.
								return cell.value.name + '<img onclick="javascript:addNewItem(' + cell.id + ')" src="images/plus.png">';
								break;
                            default:
                            	throw "getLabel for HTML Labels unexpected objectType: " + cell.value.objectType;
                        }
					}

					return mxGraph.prototype.getLabel.apply(this, arguments); // "supercall"
				};

				// Disables drag-and-drop into non-swimlanes.
				graph.isValidDropTarget = function (cell, cells, evt) {
					return this.isSwimlane(cell);
				};

				// Installs a popupmenu handler using local function (see below).
				graph.popupMenuHandler.factoryMethod = function (menu, cell, evt) {
					createPopupMenu(editor, graph, menu, cell, evt);
				};

				// Adds all required styles to the graph (see below)
				configureStylesheet(graph);

				addSidebarIcon(graph, sidebar, ObjectType.ENTITY, 'images/icons48/entity.png');
				//addSidebarIcon(graph, sidebar, ObjectType.ENTITY, 'images/icons48/abstract_entity.png');
				//addSidebarIcon(graph, sidebar, ObjectType.COLUMN, 'images/icons48/column.png');

				graph.addEdge = function (edge, parent, source, target, index) {

					return RelationManager.openPopupToEditProperties(graph, edge, function(newRelation) {
						graph.model.beginUpdate();
						try {
							edge.value = newRelation;
							return mxGraph.prototype.addEdge.apply(graph, [edge, parent, source, target, index]); // "supercall"
						} finally {
							graph.model.endUpdate();
						}
                    },
                        function() {
						    //supercall not being called. Suposedly the Edge will not be created.
						    return null;
					    }
                    );
				};

				// Displays useful hints in a small semi-transparent box.
				const hints = document.createElement('div');
				hints.style.position = 'absolute';
				hints.style.overflow = 'hidden';
				hints.style.width = '230px';
				hints.style.bottom = '56px';
				hints.style.height = '86px';
				hints.style.right = '20px';

				hints.style.background = 'black';
				hints.style.color = 'white';
				hints.style.fontFamily = 'Arial';
				hints.style.fontSize = '10px';
				hints.style.padding = '4px';

				mxUtils.setOpacity(hints, 50);

				mxUtils.writeln(hints, '- Drag an image from the sidebar to the graph');
				mxUtils.writeln(hints, '- Doubleclick on a table or column to edit');
				mxUtils.writeln(hints, '- Shift- or Rightclick and drag for panning');
				mxUtils.writeln(hints, '- Move the mouse over a cell to see a tooltip');
				mxUtils.writeln(hints, '- Click and drag a table to move and connect');
				mxUtils.writeln(hints, '- Shift- or Rightclick to show a popup menu');
				document.body.appendChild(hints);

				// Creates a new DIV that is used as a toolbar and adds
				// toolbar buttons.
				const spacer = document.createElement('div');
				spacer.style.display = 'inline';
				spacer.style.padding = '8px';

				addToolbarButton(editor, toolbar, 'properties', 'Properties', 'editors/images/properties.gif');
				editor.addAction('properties', function (editor, cell) {
					if (cell == null) {
						cell = graph.getSelectionCell();
					}

					const manager = ManagerFactory.createManager(cell.value.objectType);
					console.log(manager);
					if (manager.hasEditableProperties()) {
						manager.openPopupToEditProperties(graph, cell, function(newValue){
							//Garantees the same internalUUID. Maybe we should check if new or preexisting object
                            //TODO: And try to clone? There was some problem if the object wasn't being cloned before, but
                            //They might not exist anymore...
                            //newValue.internalUUID = cell.value.internalUUID;

							graph.model.setValue(cell, newValue);
                        });
                    }
				});

				addToolbarButton(editor, toolbar, 'delete', 'Delete', 'images/delete2.png');

				toolbar.appendChild(spacer.cloneNode(true));

				addToolbarButton(editor, toolbar, 'undo', '', 'images/undo.png');
				addToolbarButton(editor, toolbar, 'redo', '', 'images/redo.png');

				toolbar.appendChild(spacer.cloneNode(true));

				addToolbarButton(editor, toolbar, 'show', 'Show', 'images/camera.png');
				addToolbarButton(editor, toolbar, 'print', 'Print', 'images/printer.png');

				toolbar.appendChild(spacer.cloneNode(true));

				// Defines export XML action
				editor.addAction('export', function (editor, cell) {
					var textarea = document.createElement('textarea');
					textarea.style.width = '400px';
					textarea.style.height = '400px';
					var enc = new mxCodec(mxUtils.createXmlDocument());
					var node = enc.encode(editor.graph.getModel());
					textarea.value = mxUtils.getPrettyXml(node);
					showModalWindow('XML', textarea, 410, 440);
				});

				addToolbarButton(editor, toolbar, 'export', 'Export XML', 'images/export1.png');

				// Adds toolbar buttons into the status bar at the bottom
				// of the window.
				addToolbarButton(editor, status, 'collapseAll', 'Collapse All', 'images/navigate_minus.png', true);
				addToolbarButton(editor, status, 'expandAll', 'Expand All', 'images/navigate_plus.png', true);

				status.appendChild(spacer.cloneNode(true));

				addToolbarButton(editor, status, 'zoomIn', '', 'images/zoom_in.png', true);
				addToolbarButton(editor, status, 'zoomOut', '', 'images/zoom_out.png', true);
				addToolbarButton(editor, status, 'actualSize', '', 'images/view_1_1.png', true);
				addToolbarButton(editor, status, 'fit', '', 'images/fit_to_size.png', true);

				// Creates the outline (navigator, overview) for moving
				// around the graph in the top, right corner of the window.
				const outln = new mxOutline(graph, outline);

				// Fades-out the splash screen after the UI has been loaded.
				const splash = document.getElementById('splash');
				if (splash != null) {
					try {
						mxEvent.release(splash);
						mxEffects.fadeOut(splash, 100, true);
					} catch (e) {

						// mxUtils is not available (library not loaded)
						splash.parentNode.removeChild(splash);
					}
				}
			}
		}

		function addToolbarButton (editor, toolbar, action, label, image, isTransparent) {
			const button = document.createElement('button');
			button.style.fontSize = '10';
			if (image != null) {
				var img = document.createElement('img');
				img.setAttribute('src', image);
				img.style.width = '16px';
				img.style.height = '16px';
				img.style.verticalAlign = 'middle';
				img.style.marginRight = '2px';
				button.appendChild(img);
			}
			if (isTransparent) {
				button.style.background = 'transparent';
				button.style.color = '#FFFFFF';
				button.style.border = 'none';
			}
			mxEvent.addListener(button, 'click', function (evt) {
				editor.execute(action);
			});
			mxUtils.write(button, label);
			toolbar.appendChild(button);
		}

		function showModalWindow (title, content, width, height) {
			var background = document.createElement('div');
			background.style.position = 'absolute';
			background.style.left = '0px';
			background.style.top = '0px';
			background.style.right = '0px';
			background.style.bottom = '0px';
			background.style.background = 'black';
			mxUtils.setOpacity(background, 50);
			document.body.appendChild(background);

			if (mxClient.IS_QUIRKS) {
				new mxDivResizer(background);
			}

			const x = Math.max(0, document.body.scrollWidth / 2 - width / 2);
			const y = Math.max(10, (document.body.scrollHeight ||
				document.documentElement.scrollHeight) / 2 - height * 2 / 3);
			const wnd = new mxWindow(title, content, x, y, width, height, false, true);
			wnd.setClosable(true);

			// Fades the background out after after the window has been closed
			wnd.addListener(mxEvent.DESTROY, function (evt) {
				mxEffects.fadeOut(background, 50, true,
					10, 30, true);
			});

			wnd.setVisible(true);

			return wnd;
		}

		function addSidebarIcon (graph, sidebar, sidebarObjectType, image) {

			// Function that is executed when the image is dropped on
			// the graph. The cell argument points to the cell under
			// the mousepointer if there is one.
			const imageDroppedOnGraphFunction = function (graph, event, cell) {
				console.log(graph, event, cell);
				graph.stopEditing(false);

				const eventPoint = graph.getPointForEvent(event);

				let parent = graph.getDefaultParent();
				const model = graph.getModel();

				let name = null;

				model.beginUpdate();
				try {
					console.log(sidebarObjectType);
					const manager = ManagerFactory.createManager(sidebarObjectType);
					console.log(manager);
    				const newCell = manager.insertNewObject(graph, event, cell);
					graph.setSelectionCell(newCell);
                } finally {
                    model.endUpdate();
                }

			};

			// Creates the image which is used as the sidebar icon (drag source)
			const img = document.createElement('img');
			img.setAttribute('src', image);
			img.style.width = '48px';
			img.style.height = '48px';
			img.title = 'Drag this to the diagram to create a new vertex';
			sidebar.appendChild(img);

			// Creates the image which is used as the drag icon (preview)
			const dragImage = img.cloneNode(true);
			const ds = mxUtils.makeDraggable(img, graph, imageDroppedOnGraphFunction, dragImage);

			// Adds highlight of target tables for columns
			ds.highlightDropTargets = true;
			ds.getDropTarget = function (graph, x, y) {
				console.log(sidebarObjectType);
				if (sidebarObjectType === ObjectType.ENTITY) {
					return null;
				}

                const cell = graph.getCellAt(x, y);
				console.log(cell);
                if (cell && cell.value && cell.value.objectType === ObjectType.ENTITY) {
					console.log(cell.value.objectType, cell.value);
                    return cell;
                }

                const cellParent = graph.getModel().getParent(cell);
                if (cellParent && cellParent.value && cellParent.value.objectType === ObjectType.ENTITY) {
					console.log(cellParent.value, cellParent.value.objectType);
                    return cellParent;
                }

                //Now We have Column Lanes, we want to drop columns in the Entity, so we need to check
                //for grandparents
                if (cellParent) {
					const cellGrandParent = graph.getModel().getParent(cellParent);
					if (cellGrandParent && cellGrandParent.value && cellGrandParent.value.objectType === ObjectType.ENTITY) {
						return cellGrandParent;
					}
				}

                return null;
			};
		}

		function configureStylesheet (graph) {
			let vertexStyle = {};
			vertexStyle[mxConstants.STYLE_SHAPE] = mxConstants.SHAPE_RECTANGLE;
			vertexStyle[mxConstants.STYLE_PERIMETER] = mxPerimeter.RectanglePerimeter;
			vertexStyle[mxConstants.STYLE_ALIGN] = mxConstants.ALIGN_LEFT;
			vertexStyle[mxConstants.STYLE_VERTICAL_ALIGN] = mxConstants.ALIGN_MIDDLE;
			vertexStyle[mxConstants.STYLE_FONTCOLOR] = '#000000';
			vertexStyle[mxConstants.STYLE_FONTSIZE] = '11';
			vertexStyle[mxConstants.STYLE_FONTSTYLE] = 0;
			vertexStyle[mxConstants.STYLE_SPACING_LEFT] = '4';
			vertexStyle[mxConstants.STYLE_IMAGE_WIDTH] = '48';
			vertexStyle[mxConstants.STYLE_IMAGE_HEIGHT] = '48';
			graph.getStylesheet().putDefaultVertexStyle(vertexStyle);

			let entityStyle = {};
			entityStyle[mxConstants.STYLE_SHAPE] = mxConstants.SHAPE_SWIMLANE;
			entityStyle[mxConstants.STYLE_PERIMETER] = mxPerimeter.RectanglePerimeter;
			entityStyle[mxConstants.STYLE_ALIGN] = mxConstants.ALIGN_CENTER;
			entityStyle[mxConstants.STYLE_VERTICAL_ALIGN] = mxConstants.ALIGN_TOP;
			entityStyle[mxConstants.STYLE_GRADIENTCOLOR] = '#41B9F5';
			entityStyle[mxConstants.STYLE_FILLCOLOR] = '#8CCDF5';
			entityStyle[mxConstants.STYLE_SWIMLANE_FILLCOLOR] = '#ffffff';
			entityStyle[mxConstants.STYLE_STROKECOLOR] = '#1B78C8';
			entityStyle[mxConstants.STYLE_FONTCOLOR] = '#000000';
			entityStyle[mxConstants.STYLE_STROKEWIDTH] = '2';
			entityStyle[mxConstants.STYLE_STARTSIZE] = '28';
			entityStyle[mxConstants.STYLE_VERTICAL_ALIGN] = 'middle';
			entityStyle[mxConstants.STYLE_FONTSIZE] = '12';
			entityStyle[mxConstants.STYLE_FONTSTYLE] = 1;
			entityStyle[mxConstants.STYLE_IMAGE] = 'images/icons48/entity.png';
			// Looks better without opacity if shadow is enabled
			//style[mxConstants.STYLE_OPACITY] = '80';
			entityStyle[mxConstants.STYLE_SHADOW] = 1;
			graph.getStylesheet().putCellStyle(CELL_STYLES.ENTITY, entityStyle);


			let entityLaneStyle = {};
			entityLaneStyle[mxConstants.STYLE_SHAPE] = mxConstants.SHAPE_SWIMLANE;
			entityLaneStyle[mxConstants.STYLE_PERIMETER] = mxPerimeter.RectanglePerimeter;
			entityLaneStyle[mxConstants.STYLE_ALIGN] = mxConstants.ALIGN_CENTER;
			entityLaneStyle[mxConstants.STYLE_VERTICAL_ALIGN] = mxConstants.ALIGN_TOP;
			entityLaneStyle[mxConstants.STYLE_GRADIENTCOLOR] = '#2A92A1';
			entityLaneStyle[mxConstants.STYLE_FILLCOLOR] = '#6b7388';
			entityLaneStyle[mxConstants.STYLE_SWIMLANE_FILLCOLOR] = '#ffffff';
			entityLaneStyle[mxConstants.STYLE_STROKECOLOR] = '#1B78C8';
			entityLaneStyle[mxConstants.STYLE_FONTCOLOR] = '#000000';
			entityLaneStyle[mxConstants.STYLE_STROKEWIDTH] = '2';
			entityLaneStyle[mxConstants.STYLE_STARTSIZE] = '28';
			entityLaneStyle[mxConstants.STYLE_VERTICAL_ALIGN] = 'middle';
			entityLaneStyle[mxConstants.STYLE_FONTSIZE] = '12';
			entityLaneStyle[mxConstants.STYLE_FONTSTYLE] = 1;
			//entityLaneStyle[mxConstants.STYLE_IMAGE] = 'images/icons48/entity.png';
			// Looks better without opacity if shadow is enabled
			entityLaneStyle[mxConstants.STYLE_OPACITY] = '80';
			//entityLaneStyle[mxConstants.STYLE_SHADOW] = 1;
			graph.getStylesheet().putCellStyle(CELL_STYLES.ENTITY_LANE, entityLaneStyle);


			let abstractEntityStyle = {};
			abstractEntityStyle[mxConstants.STYLE_SHAPE] = mxConstants.SHAPE_SWIMLANE;
			abstractEntityStyle[mxConstants.STYLE_PERIMETER] = mxPerimeter.RectanglePerimeter;
			abstractEntityStyle[mxConstants.STYLE_ALIGN] = mxConstants.ALIGN_CENTER;
			abstractEntityStyle[mxConstants.STYLE_VERTICAL_ALIGN] = mxConstants.ALIGN_TOP;
			abstractEntityStyle[mxConstants.STYLE_GRADIENTCOLOR] = '#33C1A3';
			abstractEntityStyle[mxConstants.STYLE_FILLCOLOR] = '#9A33EE';
			abstractEntityStyle[mxConstants.STYLE_SWIMLANE_FILLCOLOR] = '#ffffff';
			abstractEntityStyle[mxConstants.STYLE_STROKECOLOR] = '#1E33A6';
			abstractEntityStyle[mxConstants.STYLE_FONTCOLOR] = '#000000';
			abstractEntityStyle[mxConstants.STYLE_STROKEWIDTH] = '2';
			abstractEntityStyle[mxConstants.STYLE_STARTSIZE] = '28';
			abstractEntityStyle[mxConstants.STYLE_VERTICAL_ALIGN] = 'middle';
			abstractEntityStyle[mxConstants.STYLE_FONTSIZE] = '12';
			abstractEntityStyle[mxConstants.STYLE_FONTSTYLE] = 1;
			abstractEntityStyle[mxConstants.STYLE_IMAGE] = 'images/icons48/abstract_entity.png';
			// Looks better without opacity if shadow is enabled
			//style[mxConstants.STYLE_OPACITY] = '80';
			abstractEntityStyle[mxConstants.STYLE_SHADOW] = 1;
			graph.getStylesheet().putCellStyle(CELL_STYLES.ABSTRACT_ENTITY, abstractEntityStyle);

			let defaultEdgeStyle = graph.stylesheet.getDefaultEdgeStyle();
			defaultEdgeStyle[mxConstants.STYLE_LABEL_BACKGROUNDCOLOR] = '#FFFFFF';
			defaultEdgeStyle[mxConstants.STYLE_STROKEWIDTH] = '2';
			defaultEdgeStyle[mxConstants.STYLE_ROUNDED] = true;
			defaultEdgeStyle[mxConstants.STYLE_EDGE] = mxEdgeStyle.EntityRelation;
		}

		// Function to create the entries in the popupmenu
		function createPopupMenu (editor, graph, menu, cell, evt) {

			console.log(editor, graph, menu, cell, evt);

			if (cell != null) {
				if (ManagerFactory.createManager(cell.value.objectType).hasEditableProperties()) {
					menu.addItem('Properties', 'editors/images/properties.gif', function () {
						editor.execute('properties', cell);
					});
					menu.addSeparator();
                }

				menu.addItem('Delete', 'images/delete2.png', function () {
					editor.execute('delete', cell);
				});

				menu.addSeparator();
			}

			menu.addItem('Undo', 'images/undo.png', function () {
				editor.execute('undo', cell);
			});

			menu.addItem('Redo', 'images/redo.png', function () {
				editor.execute('redo', cell);
			});

			//menu.addSeparator();

		}

		const ObjectType = {
			ENTITY: "ENTITY",
			COLUMN: "COLUMN",
			RELATION: "RELATION",
            CONSTRAINT: "CONSTRAINT",
            COMPUTED_VALUES: "COMPUTED_VALUES",
            LANE: "LANE",
            UUID: "UUID",
		};


        const ColumnTypes = {
			UUID: 'UUID',
            TEXT: 'TEXT',  // Optimization if just small strings or text or whatever on the platform
			REGEX: 'REGEX', // Maybe TEXT sub-type? Or unique? Which would be more user-friendly?
			INTEGER: 'INTEGER',  //FIXME in the future: Platform should handle integer overflow nicely
			BOOLEAN: 'BOOLEAN',
			DECIMAL: 'DECIMAL', // (max_digits, max_decimals)
			FLOAT_32: 'FLOAT_32',
			DATE_TIME: 'DATE_TIME', //Many many possibilities HISTORIC, IMPRECISE, AROUND, ERROR BAR, JUST DATE, JUST TIME, PERIODIC DAY, WEEKLY etc MILLISECONDS, MICROSECONDS, PICOSECONDS -- Platform should store only timestamps in UTC plus extra data if necessary (error bars etc) and deal with everything needed on the frontend
			SEQUENCIAL: 'SEQUENCIAL', // Allow WHERE like condition for slicing the sequence groups (given year like: invoice.fiscal_year.year)
        };

        const LaneTypes = {
        	COLUMNS: 'Columns',
            CONSTRAINTS: 'Constraints',
            COMPUTED_VALUES: 'Computed Values',
        };

		class Column {
			constructor (name, type, notNull, defaultValue) {
				this.internalUUID = uuidv4();
				this.update(name, type, notNull, defaultValue)
			}

			update (name, type, notNull, defaultValue) {
				this.name = name;
				this.type = type;
				this.defaultValue = defaultValue;
				this.notNull = notNull;
			}

			get objectType() {
				return ObjectType.COLUMN;
            }
        }

        class Entity {
			constructor (name, abstract) {
				this.internalUUID = uuidv4();
				this.update(name, abstract);
			}

			update (name, abstract) {
				this.name = name;
				this.abstract = abstract;
			}

			get objectType() {
				return ObjectType.ENTITY;
			}
        }

        class Relation {
			constructor (forwardDescription, backwardDescription, isa) {
				this.internalUUID = uuidv4();
				this.update(forwardDescription, backwardDescription, isa);
			}

			update (forwardDescription, backwardDescription, isa) {
				this.forwardDescription = forwardDescription;
				this.backwardDescription = backwardDescription;
				this.isa = isa;
			}

			get objectType() {
				return ObjectType.RELATION;
			}
        }

		class Constraint {
			constructor (name, constraint) {
				this.internalUUID = uuidv4();
				this.update(name, constraint);
			}

			update (name, constraint) {
				this.name = name;
				this.constraint = constraint;
			}

			get objectType() {
				return ObjectType.CONSTRAINT;
			}
		}

		class ComputedValue {
			constructor (name, expression) {
				this.internalUUID = uuidv4();
				this.update(name, expression);
			}

			update (name, expression) {
				this.name = name;
				this.expression = expression;
			}

			get objectType() {
				return ObjectType.COMPUTED_VALUES;
			}
		}

		//No constructor nor internalUUID, just a placeholder
		class ObjectUUID {
			get objectType() {
				return ObjectType.UUID;
			}
		}

		class Lane {
			constructor (name) {
				this.name = name;
			}

			get objectType() {
				return ObjectType.LANE;
			}
		}

        // All managers should have the interface:
		// static hasEditableProperties() : boolean
        // If it has Editable Properties:
        // static openPopupToEditProperties(graph, cell, resolve, reject)

		class ColumnManager {

			static createColumnCell(column) {
				// Adds sidebar icon for the column object
				const columnCell = new mxCell(column, new mxGeometry(0, 28, 100, 26));
				//For some reason, alternateBounds has a really big width by default?
				columnCell.geometry.alternateBounds = new mxRectangle(0, 0, columnCell.geometry.width, columnCell.geometry.height);

				columnCell.setVertex(true);
				columnCell.setConnectable(false);

				return columnCell;
			}

			static hasEditableProperties() {
				return true;
			}

			static openPopupToEditProperties(graph, cell, resolve, reject) {
				return ColumnManager.openPopupToEditColumnProperties(graph, cell.value, resolve, reject);
			}

			static openPopupToEditColumnProperties(graph, columnObject, resolve, reject) {
				const form = new mxForm('properties');

				const nameField = form.addText('Name', columnObject.name);
				const typeField = form.addText('Type', columnObject.type);

				const notNullField = form.addCheckbox('Not Null', columnObject.notNull);
				const defaultField = form.addText('Default', columnObject.defaultValue);

				let wnd = showModalWindow('Column Properties', form.table, 240, 240);

				const okFunction = function () {
                    columnObject.update(nameField.value, typeField.value, notNullField.checked, defaultField.value);
					resolve(columnObject);
					wnd.destroy();
				};

				const cancelFunction = function () {
					reject();
					wnd.destroy();
				};
				form.addButtons(okFunction, cancelFunction);
			}

			static columnObjectCreatedNowInsertNewCellIntoGraph(graph, event, targetCell, columnObject) {
				const eventPoint = graph.getPointForEvent(event);
				const parentState = graph.getView().getState(targetCell);
				console.log(targetCell, parentState);
				if (targetCell == null || parentState == null) {
					mxUtils.alert('Drop target must be a table');
					return;
				}

                const newColumnCell = ColumnManager.createColumnCell(columnObject);

                newColumnCell.geometry.x = eventPoint.x - parentState.x;
                newColumnCell.geometry.y = eventPoint.y - parentState.y;

                console.log(newColumnCell);

                graph.addCell(newColumnCell, targetCell.columnsLane);
            }

			static insertNewObject(graph, event, targetCell) {
				console.log("insertNewObject(graph, event)");
				console.log(graph, event);

				//const columnCount = graph.model.getChildCount(targetCell.columnsLane);
				//TODO: Parametrize default values
				const newColumn = ColumnManager.getDefaultColumn();

				ColumnManager.openPopupToEditColumnProperties(graph, newColumn, function(newColumn) {
					ColumnManager.columnObjectCreatedNowInsertNewCellIntoGraph(graph, event, targetCell, newColumn)
				}, function(){});
			}


			static addNewItem(graph, laneCell) {
				console.log("addNewItem(graph, laneCell)");
				console.log(graph, laneCell);

				const newColumn = ColumnManager.getDefaultColumn();

				ColumnManager.openPopupToEditColumnProperties(graph, newColumn, function(newColumn) {
					const newColumnCell = ColumnManager.createColumnCell(newColumn);
					graph.addCell(newColumnCell, laneCell);
				}, function(){});
            }

            static getDefaultColumn() {
				//const columnCount = graph.model.getChildCount(targetCell.columnsLane);
				//TODO: Parametrize default values
				return new Column('NEW COLUMN', ColumnTypes.TEXT, true, '');
            }

		}

		class RelationManager {
			static hasEditableProperties() {
				return true;
			}

			static openPopupToEditProperties(graph, edge, resolve, reject) {
				const sourceEqualsTarget = edge.source === edge.target;

				if (!edge.value) {
					//TODO: parametrize default values
					edge.value = new Relation("Forward's Relation", "Backward's Relation", false);
                }

				const currentRelation = edge.value;

				//mxEditor.prototype.propertiesWidth = 240;
				const form = new mxForm('properties');

				let isa = form.addCheckbox('IS A', currentRelation.isa);
				//FIXME: Create a constant's file for the defaults here
				const forwardDescription = form.addText('Forward relation description', currentRelation.forwardDescription);
				const backwardDescription = form.addText('Backward relation description', currentRelation.backwardDescription);

				function disableDescriptionsIfISA() {
					if (isa.checked) {
						forwardDescription.disabled = true;
						backwardDescription.disabled = true;
					} else {
						forwardDescription.disabled = false;
						backwardDescription.disabled = false;
					}
                }

				disableDescriptionsIfISA();
                isa.onchange = function () {
					disableDescriptionsIfISA();
                };

				if (sourceEqualsTarget) {
					isa.disabled = true;
				}

				let relationPropertiesWindow = null;
				const okFunction = function () {
					currentRelation.update(forwardDescription.value, backwardDescription.value , isa.checked);
					relationPropertiesWindow.destroy();
					resolve(currentRelation);
				};
				const cancelFunction = function () {
					relationPropertiesWindow.destroy();
					reject();
				};
				form.addButtons(okFunction, cancelFunction);

				relationPropertiesWindow = showModalWindow('Relation properties', form.table, 320, 200);
			}
		}

		class EntityManager {
			static hasEditableProperties() {
				return true;
			}

			static entityObjectCreatedNowInsertNewCellIntoGraph(graph, event, entityObject) {
				const defaultParent = graph.getDefaultParent();

				const eventPoint = graph.getPointForEvent(event);

				const newEntityCell = new mxCell(entityObject, new mxGeometry(0, 0, 200, 28), entityObject.abstract?CELL_STYLES.ABSTRACT_ENTITY:CELL_STYLES.ENTITY);
				newEntityCell.setVertex(true);
				//For some reason, alternateBounds has a really big width by default?
				newEntityCell.geometry.alternateBounds = new mxRectangle(0, 0, newEntityCell.geometry.width, newEntityCell.geometry.height);

				newEntityCell.geometry.x = eventPoint.x;
				newEntityCell.geometry.y = eventPoint.y;

				console.log(newEntityCell, defaultParent);
				graph.addCell(newEntityCell, defaultParent);
				//PSEUDO-COLUMN: Is this the best way to do it? Maybe create a real Column Object?
                //Maybe create a new type and add it to isHtmlLabel?
				const uuidColumn = new Column('ID', ColumnTypes.UUID, true, '');
                uuidColumn.primaryKey=  true;
				const idColumn = ColumnManager.createColumnCell(uuidColumn);

				graph.addCell(idColumn, newEntityCell);
				console.log(graph);

				//FIXME: Lanes creation code should be moved to the LaneManager
				const columnsLane = new mxCell(new Lane('Columns'), new mxGeometry(0, 56, 200, 28), CELL_STYLES.ENTITY_LANE);
				columnsLane.setVertex(true);
				columnsLane.setConnectable(false);
				//This was in the original code what is its purpose?
				columnsLane.geometry.alternateBounds = new mxRectangle(0, 0, columnsLane.geometry.width, columnsLane.geometry.height);

				//Column ID not appearing correctly at first
				const constraintsLane = new mxCell(new Lane('Constraints'), new mxGeometry(0, 112, 200, 28), CELL_STYLES.ENTITY_LANE);
				constraintsLane.setVertex(true);
				constraintsLane.setConnectable(false);
				constraintsLane.geometry.alternateBounds = new mxRectangle(0, 0, constraintsLane.geometry.width, constraintsLane.geometry.height);


				const computedValuesLane = new mxCell(new Lane('Computed Values'), new mxGeometry(0, 140, 200, 28), CELL_STYLES.ENTITY_LANE);
				computedValuesLane.setVertex(true);
				computedValuesLane.setConnectable(false);
				computedValuesLane.geometry.alternateBounds = new mxRectangle(0, 0, computedValuesLane.geometry.width, computedValuesLane.geometry.height);

				newEntityCell.columnsLane = columnsLane;
				newEntityCell.constraintsLane = constraintsLane;
				newEntityCell.computedValuesLane = computedValuesLane;

				graph.addCell(columnsLane, newEntityCell);
				graph.addCell(constraintsLane, newEntityCell);
				graph.addCell(computedValuesLane, newEntityCell);

				console.log(graph);

				return newEntityCell;
            }

			static insertNewObject(graph, event, targetCell) {
				console.log("insertNewObject(graph, event)");
				console.log(graph, event);

				//TODO: Default values for new Entity, parametrize
				const newEntityObject = new Entity('New Entity', false);
				EntityManager.openPopupToEditPropertiesEntityObject(graph, newEntityObject,
                    function(entityObject){
					    EntityManager.entityObjectCreatedNowInsertNewCellIntoGraph(graph, event, entityObject)
				    },
                    function(){}
                );
			}

			static openPopupToEditProperties(graph, cell, resolve, reject) {
				EntityManager.openPopupToEditPropertiesEntityObject(graph, cell.value, resolve, reject);
			}

			static openPopupToEditPropertiesEntityObject(graph, entityObject, resolve, reject) {
				//mxEditor.prototype.propertiesWidth = 240;
				const form = new mxForm('properties');

				const nameTextbox = form.addText('Name', entityObject.name);
				let isAbstractCheckbox = form.addCheckbox('Abstract Entity?', entityObject.isAbstract);

				let entityPropertiesWindow = showModalWindow('Entity Properties', form.table, 320, 200);

				const okFunction = function () {
					entityObject.update(nameTextbox.value, isAbstractCheckbox.checked);
					resolve(entityObject);
					entityPropertiesWindow.destroy();
				};

				const cancelFunction = function () {
					reject();
					entityPropertiesWindow.destroy();
				};

				form.addButtons(okFunction, cancelFunction);
			}

		}


		class ConstraintManager {

			static createConstraintCell(constraint) {
				// Adds sidebar icon for the column object
				const constraintCell = new mxCell(constraint, new mxGeometry(0, 28, 100, 26));
				//For some reason, alternateBounds has a really big width by default?
				constraintCell.geometry.alternateBounds = new mxRectangle(0, 0, constraintCell.geometry.width, constraintCell.geometry.height);

				constraintCell.setVertex(true);
				constraintCell.setConnectable(false);

				return constraintCell;
			}

			static hasEditableProperties() {
				return true;
			}

			static openPopupToEditProperties(graph, cell, resolve, reject) {
				return ConstraintManager.openPopupToEditConstraintProperties(graph, cell.value, resolve, reject);
			}

			static openPopupToEditConstraintProperties(graph, constraintObject, resolve, reject) {
				const form = new mxForm('properties');

				const nameField = form.addText('Name', constraintObject.name);
				const constraintField = form.addText('Constraint', constraintObject.constraint);

				let wnd = showModalWindow('Constraint Properties', form.table, 240, 240);

				const okFunction = function () {
					constraintObject.update(nameField.value, constraintField.value);
					resolve(constraintObject);
					wnd.destroy();
				};

				const cancelFunction = function () {
					reject();
					wnd.destroy();
				};
				form.addButtons(okFunction, cancelFunction);
			}

			static addNewItem(graph, laneCell) {
				console.log("addNewItem(graph, laneCell)");
				console.log(graph, laneCell);

				const newConstraint = ConstraintManager.getDefaultConstraint();

				ConstraintManager.openPopupToEditConstraintProperties(graph, newConstraint, function(newConstraint) {
					const constraintCell = ConstraintManager.createConstraintCell(newConstraint);
					graph.addCell(constraintCell, laneCell);
				}, function(){});
			}

			static getDefaultConstraint() {
				//const constraintCount = graph.model.getChildCount(targetCell.constraintsLane);
				//TODO: Parametrize default values
				return new Constraint('NEW CONSTRAINT', 'true');
			}

		}



		class ComputedValueManager {

			static createComputedValueCell(computedValue) {
				// Adds sidebar icon for the column object
				const computedValueCell = new mxCell(computedValue, new mxGeometry(0, 28, 100, 26));
				//For some reason, alternateBounds has a really big width by default?
				computedValueCell.geometry.alternateBounds = new mxRectangle(0, 0, computedValueCell.geometry.width, computedValueCell.geometry.height);

				computedValueCell.setVertex(true);
				computedValueCell.setConnectable(false);

				return computedValueCell;
			}

			static hasEditableProperties() {
				return true;
			}

			static openPopupToEditProperties(graph, cell, resolve, reject) {
				return ComputedValueManager.openPopupToEditComputedValueProperties(graph, cell.value, resolve, reject);
			}

			static openPopupToEditComputedValueProperties(graph, computedValueObject, resolve, reject) {
				const form = new mxForm('properties');

				const nameField = form.addText('Name', computedValueObject.name);
				const expressionField = form.addText('ComputedValue', computedValueObject.expression);

				let wnd = showModalWindow('ComputedValue Properties', form.table, 240, 240);

				const okFunction = function () {
					computedValueObject.update(nameField.value, expressionField.value);
					resolve(computedValueObject);
					wnd.destroy();
				};

				const cancelFunction = function () {
					reject();
					wnd.destroy();
				};
				form.addButtons(okFunction, cancelFunction);
			}

			static addNewItem(graph, laneCell) {
				console.log("addNewItem(graph, laneCell)");
				console.log(graph, laneCell);

				const newComputedValue = ComputedValueManager.getDefaultComputedValue();

				ComputedValueManager.openPopupToEditComputedValueProperties(graph, newComputedValue, function(newComputedValue) {
					const computedValueCell = ComputedValueManager.createComputedValueCell(newComputedValue);
					graph.addCell(computedValueCell, laneCell);
				}, function(){});
			}

			static getDefaultComputedValue() {
				//const computedValueCount = graph.model.getChildCount(targetCell.computedValuesLane);
				//TODO: Parametrize default values
				return new ComputedValue('IS TURTLE', 'name like "%Turtle%"');
			}

		}



		class LaneManager {
			static createManagerForLaneObject (laneName) {
				switch (laneName) {
					case LaneTypes.COLUMNS:
						return ColumnManager;
					case LaneTypes.CONSTRAINTS:
						return ConstraintManager;
					case LaneTypes.COMPUTED_VALUES:
						return ComputedValueManager;
                    default:
                    	throw "Unknown Lane Type: " + laneName;
                }
            }

			static hasEditableProperties() {
				return false;
			}
		}

		class ManagerFactory {
			static createManager(objectType) {
				switch (objectType) {
					case ObjectType.COLUMN:
						return ColumnManager;
					case ObjectType.ENTITY:
						return EntityManager;
					case ObjectType.RELATION:
						return RelationManager;
					case ObjectType.CONSTRAINT:
						return ConstraintManager;
					case ObjectType.COMPUTED_VALUES:
						return ComputedValueManager;
                    default:
						console.log(objectType);
						throw "Unknown Class to create factory for";
				}
			}
		}


    </script>
</head>

<!-- Page passes the container for the graph to the program -->
<body onload="main(document.getElementById('graphContainer'),
			document.getElementById('outlineContainer'),
		 	document.getElementById('toolbarContainer'),
			document.getElementById('sidebarContainer'),
			document.getElementById('statusContainer'));">

<!-- Creates a container for the splash screen -->
<div id="splash"
     style="position:absolute;top:0px;left:0px;width:100%;height:100%;background:white;z-index:1;">
    <center style="padding-top:230px;">
        <img src="editors/images/loading.gif">
    </center>
</div>

<!-- Creates a container for the sidebar -->
<div id="toolbarContainer"
     style="position:absolute;white-space:nowrap;overflow:hidden;top:0px;left:0px;max-height:24px;height:36px;right:0px;padding:6px;background-image:url('images/toolbar_bg.gif');">
</div>

<!-- Creates a container for the toolboox -->
<div id="sidebarContainer"
     style="position:absolute;overflow:hidden;top:36px;left:0px;bottom:36px;max-width:52px;width:56px;padding-top:10px;padding-left:4px;background-image:url('images/sidebar_bg.gif');">
</div>

<!-- Creates a container for the graph -->
<div id="graphContainer"
     style="position:absolute;overflow:hidden;top:36px;left:60px;bottom:36px;right:0px;">
</div>

<!-- Creates a container for the outline -->
<div id="outlineContainer"
     style="position:absolute;overflow:hidden;top:36px;right:0px;width:200px;height:140px;background:transparent;border-style:solid;border-color:black;">
</div>

<!-- Creates a container for the sidebar -->
<div id="statusContainer"
     style="text-align:right;position:absolute;overflow:hidden;bottom:0px;left:0px;max-height:24px;height:36px;right:0px;color:white;padding:6px;background-image:url('images/toolbar_bg.gif');">
    <div style="font-size:10pt;float:left;">
        Created with <a href="http://www.jgraph.com" target="_blank">mxGraph</a>
    </div>
</div>

</body>
</html>
